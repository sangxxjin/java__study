변수 
	- 값을 저장할 수 있는 메모리의 공간을 의미한다.
- 하나의 값을 저장할 수 있는 메모리 공간
	- 선언된 블록 내에서만 사용이 가능하다.
변수의 선언
	- 타입 변수이름; <- 과 같이 변수를 선언한다. 
 	   ex) int age; // 정수(int)값을 저장할 수 있는 age 변수 선언
 	      double value;// 실수(double)값을 저장할 수 있는 value 변수 선언
	- 같은 타입의 변수는 콤마(,)를 이용하여 한꺼번에 선언할 수도 있다. 
 	  ex) int x,y,z;
	- 변수 이름은 자바 언어에서 정한 아래의 명명 규칙(namin convention)을 따라야한다.
작성 규칙	예
첫 번째 글자는 문자이거나 '$','_'이어야 하고 숫자로 시작할 수 없다. (필수)	가능: price, $_companyName
안됨: 1v, @speed,$#value
영어 대소문자가 구분된다. (필수)	firstnaame과 firtName은 다른 변수
첫 문자는 영어 소문자로 시작하되, 다른 단어가 붙을 경우 첫 문자를 대문자로 한다.(관례)	maxSpeed, firstName, carBodyColor
문자 수(길이)의 제한은 없다.	
자바 예약어는 사용할 수 없다.(필수)	

변수 값 저장
	- 변수에 값을 저장할 때에는 대입 연산자(=)를 사용한다.
	- 자바 언어에서는 우측의 값을 좌측 변수에 저장한다는 의미를 갖는다.
		- 변수를 선언하고 처음 값을 저장할 경우, 이러한 값을 초기값이라고 한다. 그리고 	  	  변수에 초기 값을 주는 행위를 변수의 초기화라고 한다.
	- 변수 선언과 초기화는 따로 할 수도 있고 동시에 할 수도 있다.
	Ex) int score1; //변수 선언
 	   score1 = 90; // 값 저장 
 	   int score 2= 90; // 변수 선엄함과 동시에 초기값 저장

리터럴
 	- 변수의 초기값은 코드에서 직접 입력하는 경우가 많은데, 소스 코드 내에서 직접
 	  입력된 값은 리터럴(literal)이라고 부른다.
 	- 리터럴은 값의 종류에 따라 정수 리터럴, 실수 리터럴, 문자 리터럴, 논리 리터럴로 
 	  구분된다.
 	- 리터럴은 상수와 같은 의미지만, 상수를 “값을 한번 저장하면 변경할 수 없는 변수”로
 	  정의하기 때문에 이와 구분하기 위해 리터럴이라는 용어를 사용한다.
	1) 정수 리터럴
 	  - 소수점이 없는 정수 리터럴은 10진수로 간주한다.
 	    ex) 0, 75, -100
 	  - 0으로 시작되는 리터럴은 8진수로 간주한다.
 	    ex) 02,-04
 	  - 0x 또는 0X로 시작하고 0~9 숫자나 A,B,C,D,E,F 또는 a,b,c,d,e,f,로 구성된 리터럴은
 	    16진수로 간주한다
 	    ex) 0x5, 0xA, 0xB3, 0xAC08
 	  - 정수 리터럴을 저장할 수 있는 타입은 byte, char, short, int, long이 있다.
 	 2) 실수 리터럴
 	  - 소수점이 있는 리터럴은 10진수 실수로 간주한다.
 	    ex) 0.25, -3.14
 	  - 대문자 E 또는 소문자 e가 있는 리터럴은 10진수 지수와 가수로 간주한다.
 	    ex) 5E7 (= 5 x 10^7)
 	       0.12E-5 (= 0.12 x 10^-5)
 	  - 실수 리터럴을 저장할 수 있는 타입은 float, double이 있다.
 	 3) 문자 리터럴
 	  - 작은 따옴표로 묶은 텍스트는 하나의 문자 리터럴로 간주한다.
 	   ex) ‘A’, ‘한’, ‘\t’, \n’
 	  - 문자 리터럴을 저장할 수 있는 타입은 char 하나 뿐이다.
   	 4) 문자열 리터럴
 	  - 큰따옴표로 묶은 텍스트는 문자열 리터럴로 간주한다. 큰따옴표 안에는 텍스트가
 	    없어도 문자열 리터럴로 간주된다.
 	  - 문자열 리터럴 내부에서는 이스케이프 문자를 사용할 수 있다.
 	   ex) “대한민국”
 	       “탭 만큼 이동 \t 합니다.”
 	       “ 한 줄 내려 쓰기 \n 합니다.
 	  - 문자열 리터럴을 저장할 수 있는 타입은 String 하나 뿐이다.
 	 5) 논리 리터럴
 	  - ture와 false는 논리 리터럴로 간주한다.
 	   ex) true, false
 	  - 논리 리터럴을 저장할 수 있는 타입은 boolean 하나 뿐이다.
데이터 타입 (1byte = 8bit)
	정수 - byte(8bit), char(16bit), short(16bit), int(32bit), long(64bit)
	실수 - float(32bit), double(64bit)
	논리 - boolean(8bit)
변수 값 읽기
 	- 변수는 초기화가 되어야 읽을 수 있고, 초기화되지 않은 변수는 읽을 수 없다.
변수의 사용 범위
	- 변수는 중괄호 블록 내에서 선언되고 사용된다. 중괄호 블록은 클래스, 생성자,
 	  메소드에서 사용된다.
 	- 메소드 블록내에서 선언된 변수는 로컬 변수(local variable)라고 부른다.
 	  로컬 변수는 메소드 실행이 끝나면 메모리에서 자동으로 없어진다.
	- 변수는 선언된 블록 내에서만 사용이 가능하다.
데이터 타입
	- 모든 변수에는 타입이 있으며, 타입에 따라 저장할 수 있는 값의 종류와 범위가
 	  달라진다.
 	1)기본(원시: primitive) 타입
 	 - 기본 타입이란 정수, 실수, 문자, 논리 리터럴을 직접 저장하는 타입을 말한다.
정수 타입
기본타입	메모리 사용 크기	저장되는 값의 범위
byte	1 byte = 8 bit	-128 ~ 127
char	2 byte = 16bit	0~65,535
short	2 byte = 16bit	-32768~32767
int	4 byte = 32bit	-2147483648~2147483647
long	8 byte = 64bit	-9,223,372,036,854,775,808
~ 9,223,372,036,854,775,807

실수 타입
기본 타입	메모리 사용 크기	저장되는 값의 범위
float	4 byte = 32 bit	1.4E-45 ~ 3.4028235E38
double	8 byte = 64 bit	4.9E-324 ~ 1.7976931348623157E308

논리 타입
기본 타입	메모리 사용 크기	저장되는 값의 범위
boolean	1 byte = 8bit	True, false

타입 변환 
 	- 타입 변환이란 데이터 타입을 다른 데이터 타입으로 변환하는 것을 말한다.
 	- 타입 변환에는 자동(묵시적) 타입 변환이 있고, 강제(명시적) 타입 변환이 있다.
	1)자동 타입 변환
 	 - 자동 타입 변환(Promotion)은 프로그램 실행 도중에 자동적으로 타입 변환이
 	   일어나는 것을 말한다.
 	 - 자동 타입 변환은 작은 크기를 가지는 타입이 큰 크기를 가지는 타입에 저장될 때
 	   발생한다.
 	 - 큰 크기 타입과 작은 크기 타입의 구분은 사용하는 메모리 크기이다.
 	 - 크기별로 타입을 정리하면 다음과 같다
 	   byte(1) < short(2) < int(4) < long(8) < float(4) < double(8)
 	   ※ 단 char은 2byte의 크기를 가지지만, char의 범위는 0~65535 이므로 음수가
 	      저장 될 수 없다.
              따라서 음수가 저장될 수 있는 byte 타입을 char 타입으로 자동 변환시킬 수 없다.
 	2) 강제 타입 변환
 	 - 큰 크기의 타입은 작은 크기의 타입으로 자동 타입 변환을 할 수 없다.
 	 - 대신 강제적으로 큰 데이터 타입을 작은 데이터 타입으로 쪼개어서 저장하는 것은
 	   가능한데, 이것을 강제 타입 변환(캐스팅 : Casting)이라고 한다.
 	 - 강제 타입 변환은 캐스팅 연산자 ()를 사용하는데, 괄호 안에 들어가는 타입은 쪼개는
 	   단위이다.
 	 - 아래는 int 타입 변수를 byte타입 변수로 강제 타입 변환을 시키는 코드이다.
 	   ex) int intValue = 103029770;
 	      byte byteValue = (byte) intValue; // 강제 타입 변환
 	 - 위의 코드에서 byteValue 변수에는 103029770이 아닌 10이 저장된다.
 	   왜냐하면 intValue 변수의 값들 중 끝에 있는 1 byte만 byteValue 변수에 저장되었기
 	   때문이다.
 	 - 위의 경우처럼 강제 타입 변환을 할 땐 값이 손실되지 않도록 하는 것이 중요한데, 
 	   이를위해 강제 타입 변환을 하기 전에 if 문을 통해 안전하게 값이 보존될 수 있는지
 	   검사한 후에 강제 타입 변환을 하는 것이 좋다
 	 - 이를 위해 자바에서는 boolean과 char 타입을 제외한 모든 기본 타입의 최대값과
 	   최솟값을 다음과 같이 상수로 제공하고 있다.
기본타입	최대값 상수	최솟값 상수
byte	Byte.MAX_VALUE	Byte.MIN_VALUE
short	Short.MAX_VALUE	Short.MIN_VALUE
int	Int.MAX_VALUE	Int.MIN_VALUE
long	Long.MAX_VALUE	Long.MIN_VALUE
float	Float.MAX_VALUE	Float.MIN_VALUE
double	Double.MAX_VALUE	Double.MIN_VALUE
	 - 또한 int 값을 float으로 변환하면 오류가 발생할 수 있다. 그래서 모든 int 값을
 	   안전하게 실수 타입으로 변환하고 싶으면 double 타입을 사용하는 것이 좋다.
연산식에서의 자동 타입 변환
 	- 연산은 기본적으로 같은 타입의 피연산자(operand) 간에만 수행되기 때문에 서로 다른
 	  타입의 피연산자가 있을 경우 두 피연산자 중 크기가 큰 타입으로 자동 변환된 후 
 	  연산을 수행한다.
 	- 자바는 정수 연산일 경우 int 타입을 기본으로 한다. 그 이유는 피연산를 4byte 단위로
 	  저장하기 때문이다. 크기가 4byte보다 작은 타입(byte, char, short)은 4byte인
 	  int 타입으로 변환된 후 연산이 수행된다. 따라서 연산의 결과도 int 타입이 된다.
연산자와 연산식
 	- 프로그램에서 데이터를 처리하여 결과를 산출하는 것을 연산(opeartions)이라고 한다.
 	- 연산에 사용되는 표시나 기호를 연산자(operator)라고 하고, 연산되는 데이터는
 	  피연산자(operand)라고 한다.
 	- 연산자와 피연산자를 이용하여 연산의 과정을 기술한 것을 연산식(expresstions) 이라고
 	  부른다.
연산의 방향과 우선순위
 	1. 단항, 이항, 삼항 연산자 순으로 우선순위를 가진다.
 	2. 산술, 비교, 논리, 대입 연산자 순으로 우선순위를 가진다.
 	3. 단항과 대입 연산자를 제외한 모든 연산의 방향은 왼쪽에서 오른쪽이다.
 	4. 복잡한 연산식에는 괄호를 사용해서 우선순위를 정해준다.
단항 연산자
 	- 단항 연산자는 피연산자가 단 하나뿐인 연산자를 말하며, 여기에는 부호 연산자,
 	  증감 연산자, 논리 부정 연산자, 비트 반전 연산자가 있다.
 	1) 부호 연산자(+,-)
 	 - 부호 연산자는 양수 및 음수를 표시하는 +,-를 말한다.
 	 - boolean 타입과 char 타입을 제외한 나머지 기본 타입에 사용할 수 있다.
연산자	설명
+	피연산자의 부호 유지
-	피연산자의 부호 변경
 	2) 증감 연산자( ++, -- )
 	 - 증감 연산자는 변수의 값을 1 증가시키거나 1 감소시키는 연산자를 말한다.
 	 - boolean 타입을 제외한 모든 기본 타입의 피연산자에 사용할 수 있다.
연산자	설명
++피연산자	다른 연산을 수행하기 전에 피연산자의 값을 1 증가시킴
--피연산자	다른 연산을 수행하기 전에 피연산자의 값을 1 감소시킴
피연산자++	다른 연산을 수행한 후에 피연산자의 값을 1 증가시킴
피연산자--	다른 연산을 수행한 후에 피연산자의 값을 1감소시킴
 	 - ++a 와 a = a +1의 연산속도는 동일하다.
 	   왜냐하면 두 코드를 통해 생성되는 바이트 코드는 동일하기 때문이다.
 	3) 논리 부정 연산자(!)
 	 - 논리 부정 연산자는 true를 false로, false를 true로 변경하기 때문에 booelan 타입에만
 	   사용할 수 있다.
연산자	설명
!	피연산자가 ture이면 false 값을 산출
피연산자가 false이면 true 값을 산출

 	4) 비트 반전 연산자(~)
 	 - 비트 반전 연산자는 정수 타입(byte, short, int, long)의 피연산자에만 사용되며,
 	   피연산자를 2진수로 표현했을 때 비트값인 0을 1로, 1은 0으로 반전한다.
 	 - 연산 후, 부호 비트인 최상위 비트를 포함해서 모든 비트가 반전되기 때문에,
 	   부호가 반대인 새로운 값이 산출된다.
연산자	설명
~	피연산자를 2진수로 표현했을 때, 0을 1로, 1은 0으로 반전시킴

이항 연산자
 	- 이항 연산자는 피연산자가 두 개인 연산자를 말하며 여기에는 산술 연산자, 문자열
 	  연결 연산자, 대입 연산자, 비교 연산자, 논리 연산자, 비트 논리 연산자, 비트 이동
 	  연산자 등이 있다.
 	1) 산술 연산자 ( +, -, *, /, % )
 	 - 산술 연산자는 더하기, 빼기, 곱하기, 나누기, 나머지를 구하는 연산으로 총 5개다.
 	 - 산술 연산자는 boolean 타입을 제외한 모든 기본 타입에 사용할 수 있다.
연산자	설명
+	덧셈 연산
-	뺄셈 연산
*	곱셈 연산
/	좌측 피연산자를 우측 피연산자로 나눗셈 연산
%	좌츨 피연산자를 우측 피연산자로 나눈 나머지를 구하는 연산

 	2) 문자열 연결 연산자 ( + )
 	 - 문자열 연산자인 +는 문자열을 서로 결합하는 연산자이다.
 	 - 피연산자 중 한쪽이 문자열이면 + 연산자는 문자열 연결 연산자로 사용되어 다른
 	   피연산자를 문자열로 변환하고 서로 결합한다.
 	 - 문자열과 숫자가 혼합된 + 연산식은 왼쪽에서부터 오른쪽으로 연산이 진행된다.

연산자	설명
+	왼쪽 피 연산자와 오른쪽 피연산자 중 어느 하나라도 
문자열이면 두 피연산자를 문자열로 결합함

 	 3) 비교 연산자(<,<=,>,>=,==,!=)
 	  - 비교 연산자는 대소 또는 동등을 비교해서 boolean 타입인 true/false를 산출한다.
 	  - String 타입의 문자열을 비교할 때에는 대소 연산자를 사용할 수 없고, 동등 비교
 	    연산자는 사용할 수 있으나 문자열이 같은지, 다른지를 비교하는 용도로는 사용할
 	    수 없다.
 	  - 문자열의 값이 동일한지 비교하려면 equals() 메소드를 사용해야 한다.
 		
동등비교	연산자	설명
	==	두 피연산자의 값이 같은지를 검사
	!=	두 피연산자의 값이 다른지를 검사

크기 비교	연산자	설명
	>	왼쪽 피 연산자가 큰지를 검사
	>=	왼쪽 피연산자가 크거나 같은지를 검사
	<	왼쪽 피연산자가 작은지를 검사
	<=	왼쪽 피연산자가 작거나 같은지를 검사

 	 4) 논리 연산자(&&, || ,& ,| ,! )
 	  - 논리 연산자는 논리곱, 논리합, 배타적 논리합 그리고 논리 부정 연산을 수행한다.
 	    논리 연산자의 피연산자는 boolean 타입만 사용할 수 있다.

구분	연산자	설명
AND(논리곱)	&& 또는 &	피연산자 모두가 ture일 경우에만 연산 결과는 true
OR(논리합)	|| 또는 |	피연산자 중 하나만 true이면 연산 결과는 true
XOR(배타적논리합)	^	피연산자가 하나는 true이고 다른 하나가 false일 경우에만 연산 결과는 true
NOT(논리부정)	!	피연산자의 논리값을 바꿈

 	 5) 비트 연산자(&, |, ^, ~, <<, >>, >>>)
 	  - 비트 연산자는 데이터를 비트 단위로 연산한다. 즉 0과 1이 피연산자가 된다. 그렇기
 	    때문에 0과 1로 표현이 가능한 정수 타입만 비트 연산을 할 수 있다.
 	  - 비트 연산자는 기능에 따라 비트 논리 연산자와 비트 이동 연산자로 구분한다.
 	  5-1) 비트 논리 연산자(&, |, ^)
구분	연산자	설명
AND(논리곱)	&	두 비트 모두 1일 경우에만 연산 결과가 1
OR(논리합)	|	두 비트 중 하나만 1이면 연산 결과는 1
XOR(배타적 논리합)	^	두 비트 중 하나는 1이고 다른 하나가 0일 경우 연산 결과는 1
NOT(논리 부정)	~	보수

 	  5-2) 비트 이동 연산자(<<,>>,>>>)
 		- 비트 이동 연산자는 정수 데이터의 비트를 좌측 또는 우측으로 밀어서
 	   	  이동시키는 연산을 수행한다.
연산자	설명
a << b	정수 a의 각 비트를 b만큼 왼쪽으로 이동(빈자리는 0으로 채워진다.)
a >> b	정수 a의 각 비트를 b만큼 오른쪽으로 이동(빈자리는 정수 a의 최상위 부호 비트와 같은 값으로 채워진다.)
a >>>b	정수 a의 각 비트를 b만큼 오른쪽으로 이동(빈자리는 0으로 채워진다.

 	 6) 대입 연산자 ( =, +=, -=, *=, /=, %=, ^=, |=, <<=, >>=, >>>=)
 	  - 대입 연산자는 오른쪽 피연산자의 값을 좌측 피연산자인 변수에 저장한다.
 	  - 단순히 오른쪽 피연산자의 값을 변수에 저장하는 단순 대입 연산자가 있고, 정해진
 	    연산을 수행한 후 결과를 변수에 저장하는 복합 대입 연산자도 있다.
 	  6-1) 단순 대입 연산자
연산자	설명
=	우측의 피연산자의 값을 변수에 저장
 	  6-2) 복합 대입 연산자
연산자	설명
+=	우측의 피연산자의 값을 변수의 값과 더한 후에 다시 변수에 저장
-=	우측의 피 연산자의 값을 변수의 값과 뺀 후에 다시 변수에 저장
*=	우측의 피연산자의 값을 변수의 값과 곱한 후에 다시 변수에 저장
/=	우측의 피연산자의 값으로 변수의 값을 나눈 후에 다시 변수에 저장
%=	우측의 피연산자의 값으로 변수의 값을 나눈 후에 나머지를 변수에 저장


 	 7) 삼항 연산자
 	  - 삼항 연산자(?:)는 세 개의 피연산자를 필요로 하는 연산자를 말한다. 삼항 연산자는 ?
 	    앞의 조건식에 따라 콜론(:) 앞뒤의 피연산자가 선택된다고 해서 조건 연산식이라고
 	    부르기도 한다
 	    ex) 조건식 ? 값 또는 연산식 : 값 또는 연산식
 		조건식을 연산하여 true가 나오면 삼항 연산자의 결과는 콜론 앞의 피연산자가
 		된다. 반면에 조건식을 연산하여 false가 나오면 상함 연산자의 결과는 콜론 
 		뒤의 피연산자가 된다.
조건문
 	1) if문
 	 - if문은 조건식의 결과에 따라 블록 실행 여부가 결정된다. 조건식에는 true 또는 false
 	  값을 산출할 수 있는 연산식이나, boolean 변수가 올 수 있다. 조건식이 true이면
 	  블록을 싱행하고 false이면 블록을 실행하지 않는다
 	 - if (조건식) {
 	     실행문; // 조건식이 true일 경우 실행
 	     실행문;
 	     . . .
 	     }
 	 2) if - else문
 	  - if문은 else 블록과 함께 쓰일 수 있는데, if문의 조건식이 true이면 if문의 블록이
 	    실행되고, 조건식이 false이면 else 블록이 실행된다. 조건식의 결과에 따라 두 블록
 	    중 한 블록의 내용만 실행하고 전체 if문을 벗어나게 된다.
 	 - if (조건식) {
 	     실행문; // 조건식이 true일 경우 실행
 	     실행문;
 	     . . .
 	     } else {
 	     실행문; // 조건식이 false일 경우 실행
 	     실행문;
 	     . . .
 	     }
 	 3) if - else if - else문
 	  - 조건문이 여러 개인 if문도 있다. 처음 if문의 조건식이 false일 경우 다음 조건식으로
 	    넘어가서 true인지 false인지 체크 후 실행 블록을 결정한다. 이는 if 블록 끝에 
 	    else if문을 붙이면 된다. else if문의 수는 제한이 없고, 여러 개의 조건식 중 true가
 	    되는 블록만 실행하면 전체 if문을 벗어나게 된다. else if 블록의 마지막에는 else
 	    블록을 추가할 수 있는데, 모든 조건식이 false일 경우 else 블록을 실행하고 if문을
 	    벗어나게 된다
 	 - if (조건식1) {
 	     조건식1이 true 일 경우 실행
 	   } else if (조건식2) {
 	     조건식2가 true 일 경우 실행
 	   } else { 
 	     조건식1 및 조건식2가 false 일 경우 실행
 	   }
 	 3) 중첩 if문
 	  - if문의 블록 내부에는 또 다른 if문을 사용할 수 있다. 이것을 중첩 if문이라고
 	    부르는데, 중첩의 단계는 제한이 없다.
  	  - if문만 중첩이 되는 것이 아니고, if문, switch문, for문, while문, do-while문은 서로
 	    중첩시킬 수 있다.
 	  3-1) switch문
 	   - switch문은 변수가 어떤 값을 갖느냐에 따라 실행문이 선택된다.
 	    switch (변수) {
 	 	case 값 :
 	 	     변수가 값1일 경우 실행
 	 	     break;
 	 	case 값2 :
 	 	     변수가 값2일 경우 실행
 	 	     break;
 	 	default :
 	 	     변수가 값1, 값2 모두 아닐 경우 실행
 	    }
 	   - case 끝에 break가 없으면 다음 case가 연달아 실행되는데, 이때에는 case 값과는
 	     상관없이 실행된다.
 	   - char 타입 변수도 switch문에 사용될 수 있다.
 	   - 자바 7부터는 String 타입의 변수도 switch문에 사용될 수 있다.
반복문
 	- 반복문은 어떤 작업이 반복적으로 실행되도록 할 때 사용된다.
 	1) for문
 	 - for문은 주어진 횟수만큼 실행문을 반복 실행할 때 적합한 반복 제어문이다.
 	    for (초기화식; 조건식; 증감식) {
 	     실행문; 
 	     }
 	2) while문
 	 - while문은 조건식이 true일 경우에 계속해서 반복한다.
 	 - 조건식에는 비교 또는 논리 연산식이 주로 오는데, 조건식이 false가 되면 반복
 	   행위를 멈추고 while문을 종료한다.
 	    while (조건식) {
 	     실행문; 
 	    }
 	 - while문이 처음 실행될 때 조건식을 평가한다. 평가 결과가 true이면 실행문을 실행
 	   한다. 실행문이 모두 실행되면 다시 조건식으로 되돌아서 조건식을 다시 평가한다.
 	   만약 조건식이 true라면 앞의 과정을 다시 진행하고, false라면 while문을 종료한다.
 	3) do - while
 	  - do - while문은 조건식에 의해 반복 실행한다는 점에서 while문과 동일하다.
 	  - while문은 시작할 때부터 조건식을 검사하여 블록 내부를 실행할지 결정하지만,
 	    경우에 따라서는 블록 내부의 실행문을 우선 실행시키고 실해 결과에 따라서
 	    반복 실행을 계속할지 결정하는 경우도 발생한다. 이때 do - while문을 사용 가능
 	    do {
 	     실행문; 
 	    } while (조건식);
  	  - do - while문의 while() 뒤에는 반드시 세미콜론을 붙여야 한다.
  	  - do - while문이 처음 실행될 때 실행문을 우선 실행한다. 실행문이 모두 실행되면
 	    조건식을 평가하는데, 그 결과가 true이면 실행문 -> 조건식과 같이 반복 실행을
 	    하고, 조건식의 결과가 false이면 do - while문을 종료한다.
 	3) break문
 	  - break문은 반복문인 for문, while문, do - while문을 실행 중지할 때 사용된다.
 	    또한 switch문에서 break문을 사용하여 switch문을 종료한다.
 	  - 다음과 같이 중첩된 반복문에서 바깥쪽 반복문까지 종료시키려면 바깥쪽 반복문에
 	    이름(라벨)을 붙이고, “break 이름;”을 사용하면 된다.
 	    public static void main(String[] args) { 
 	   	Outter : for(int I = 0; I < 10; I++){
 		    for(int j=0; j<10; j++){
 			system.out.println(I,j);
 			if( j == 5){
 			   break Outter;
 			}
 		    }
 		}
 	    }
  	5) continue문
 	  - continue문은 반복문인 for문, while문, do-while문에서만 사용되는데, 블록 내부에서
 	    continue문이 실행되면 for문의 증감식 또는 while문, do-while문의 조건식으로 이동
 	  - continue문은 반복문을 종료하지 않고 계속 반복을 수행한다는 점이 break문과 다름
다차원 배열
 	- 2차원 배열은 수학의 행렬을 떠올리면 되는데, 가로 인덱스와 세로 인덱스를 사용한다.
 	- 자바는 2차원 배열을 중첩 배열 방식으고 구현한다. 예를 들어 2 x 3 행렬을 만들기
 	  위해 다음과 같은 코드를 사용한다.
 	   int [] [] scores = new int [2][3];
 	- 자바는 일차원 배열이 서로 연결된 구조로 배열을 구현하기 떄문에 수학 행렬 구조가
 	  아닌 계단식 구조를 가질 수 있다.
 	  int [] [] scores = new int[2] [];
 	  scores[0] = new int[2];
 	  scores[1] = new int[3];
 	- 만약 그룹화된 값 목록을 가지고 있다면 다음과 같이 중괄호 안에 다시 중괄호를
 	  사용해서 값 목록을 나열하면 된다.
 	  타입 [] [] 변수 = { {값1, 값2, …}, {값1, 값2, …} } ;작성 규칙	예
첫 번째 글자는 문자이거나 '$','_'이어야 하고 숫자로 시작할 수 없다. (필수)	가능: price, $_companyName
안됨: 1v, @speed,$#value
영어 대소문자가 구분된다. (필수)	firstnaame과 firtName은 다른 변수
첫 문자는 영어 소문자로 시작하되, 다른 단어가 붙을 경우 첫 문자를 대문자로 한다.(관례)	maxSpeed, firstName, carBodyColor
문자 수(길이)의 제한은 없다.	
자바 예약어는 사용할 수 없다.(필수)	
기본타입	메모리 사용 크기	저장되는 값의 범위
byte	1 byte = 8 bit	-128 ~ 127
char	2 byte = 16bit	0~65,535
short	2 byte = 16bit	-32768~32767
int	4 byte = 32bit	-2147483648~2147483647
long	8 byte = 64bit	-9,223,372,036,854,775,808
~ 9,223,372,036,854,775,807
기본 타입	메모리 사용 크기	저장되는 값의 범위
float	4 byte = 32 bit	1.4E-45 ~ 3.4028235E38
double	8 byte = 64 bit	4.9E-324 ~ 1.7976931348623157E308
기본 타입	메모리 사용 크기	저장되는 값의 범위
boolean	1 byte = 8bit	True, false
기본타입	최대값 상수	최솟값 상수
byte	Byte.MAX_VALUE	Byte.MIN_VALUE
short	Short.MAX_VALUE	Short.MIN_VALUE
int	Int.MAX_VALUE	Int.MIN_VALUE
long	Long.MAX_VALUE	Long.MIN_VALUE
float	Float.MAX_VALUE	Float.MIN_VALUE
double	Double.MAX_VALUE	Double.MIN_VALUE
연산자	설명
+	피연산자의 부호 유지
-	피연산자의 부호 변경
연산자	설명
++피연산자	다른 연산을 수행하기 전에 피연산자의 값을 1 증가시킴
--피연산자	다른 연산을 수행하기 전에 피연산자의 값을 1 감소시킴
피연산자++	다른 연산을 수행한 후에 피연산자의 값을 1 증가시킴
피연산자--	다른 연산을 수행한 후에 피연산자의 값을 1감소시킴
연산자	설명
!	피연산자가 ture이면 false 값을 산출
피연산자가 false이면 true 값을 산출
연산자	설명
~	피연산자를 2진수로 표현했을 때, 0을 1로, 1은 0으로 반전시킴
연산자	설명
+	덧셈 연산
-	뺄셈 연산
*	곱셈 연산
/	좌측 피연산자를 우측 피연산자로 나눗셈 연산
%	좌츨 피연산자를 우측 피연산자로 나눈 나머지를 구하는 연산
연산자	설명
+	왼쪽 피 연산자와 오른쪽 피연산자 중 어느 하나라도 
문자열이면 두 피연산자를 문자열로 결합함
동등비교	연산자	설명
	==	두 피연산자의 값이 같은지를 검사
	!=	두 피연산자의 값이 다른지를 검사
크기 비교	연산자	설명
	>	왼쪽 피 연산자가 큰지를 검사
	>=	왼쪽 피연산자가 크거나 같은지를 검사
	<	왼쪽 피연산자가 작은지를 검사
	<=	왼쪽 피연산자가 작거나 같은지를 검사
구분	연산자	설명
AND(논리곱)	&& 또는 &	피연산자 모두가 ture일 경우에만 연산 결과는 true
OR(논리합)	|| 또는 |	피연산자 중 하나만 true이면 연산 결과는 true
XOR(배타적논리합)	^	피연산자가 하나는 true이고 다른 하나가 false일 경우에만 연산 결과는 true
NOT(논리부정)	!	피연산자의 논리값을 바꿈
구분	연산자	설명
AND(논리곱)	&	두 비트 모두 1일 경우에만 연산 결과가 1
OR(논리합)	|	두 비트 중 하나만 1이면 연산 결과는 1
XOR(배타적 논리합)	^	두 비트 중 하나는 1이고 다른 하나가 0일 경우 연산 결과는 1
NOT(논리 부정)	~	보수
연산자	설명
a << b	정수 a의 각 비트를 b만큼 왼쪽으로 이동(빈자리는 0으로 채워진다.)
a >> b	정수 a의 각 비트를 b만큼 오른쪽으로 이동(빈자리는 정수 a의 최상위 부호 비트와 같은 값으로 채워진다.)
a >>>b	정수 a의 각 비트를 b만큼 오른쪽으로 이동(빈자리는 0으로 채워진다.
연산자	설명
=	우측의 피연산자의 값을 변수에 저장
연산자	설명
+=	우측의 피연산자의 값을 변수의 값과 더한 후에 다시 변수에 저장
-=	우측의 피 연산자의 값을 변수의 값과 뺀 후에 다시 변수에 저장
*=	우측의 피연산자의 값을 변수의 값과 곱한 후에 다시 변수에 저장
/=	우측의 피연산자의 값으로 변수의 값을 나눈 후에 다시 변수에 저장
%=	우측의 피연산자의 값으로 변수의 값을 나눈 후에 나머지를 변수에 저장
&=	우측의 피연산자의 값과 변수의 값을 & 연산 후 결과를 변수에 저장
|=	우측의 피연산자의 값과 변수으 값을 | 연산 후 결과를 변수에 저장
^=	우측의 피연산자의 값과 변수의 값을 ^ 연산 후 결과를 변수에 저장
<<=	우측의 피연산자의 값과 변수의 값을 << 연산 후 결과를 변수에 저장
>>=	우측 피연산자의 값과 변수의 값을 >> 연산 후 결과를 변수에 저장
>>>=	우측의 피연산자의 값과 변수의 값을 >>> 연산 후 결과를 변수에 저장


 	 7) 삼항 연산자
 	  - 삼항 연산자(?:)는 세 개의 피연산자를 필요로 하는 연산자를 말한다. 삼항 연산자는 ?
 	    앞의 조건식에 따라 콜론(:) 앞뒤의 피연산자가 선택된다고 해서 조건 연산식이라고
 	    부르기도 한다
 	    ex) 조건식 ? 값 또는 연산식 : 값 또는 연산식
 		조건식을 연산하여 true가 나오면 삼항 연산자의 결과는 콜론 앞의 피연산자가
 		된다. 반면에 조건식을 연산하여 false가 나오면 상함 연산자의 결과는 콜론 
 		뒤의 피연산자가 된다.
조건문
 	1) if문
 	 - if문은 조건식의 결과에 따라 블록 실행 여부가 결정된다. 조건식에는 true 또는 false
 	  값을 산출할 수 있는 연산식이나, boolean 변수가 올 수 있다. 조건식이 true이면
 	  블록을 싱행하고 false이면 블록을 실행하지 않는다
 	 - if (조건식) {
 	     실행문; // 조건식이 true일 경우 실행
 	     실행문;
 	     . . .
 	     }
 	 2) if - else문
 	  - if문은 else 블록과 함께 쓰일 수 있는데, if문의 조건식이 true이면 if문의 블록이
 	    실행되고, 조건식이 false이면 else 블록이 실행된다. 조건식의 결과에 따라 두 블록
 	    중 한 블록의 내용만 실행하고 전체 if문을 벗어나게 된다.
 	 - if (조건식) {
 	     실행문; // 조건식이 true일 경우 실행
 	     실행문;
 	     . . .
 	     } else {
 	     실행문; // 조건식이 false일 경우 실행
 	     실행문;
 	     . . .
 	     }
 	 3) if - else if - else문
 	  - 조건문이 여러 개인 if문도 있다. 처음 if문의 조건식이 false일 경우 다음 조건식으로
 	    넘어가서 true인지 false인지 체크 후 실행 블록을 결정한다. 이는 if 블록 끝에 
 	    else if문을 붙이면 된다. else if문의 수는 제한이 없고, 여러 개의 조건식 중 true가
 	    되는 블록만 실행하면 전체 if문을 벗어나게 된다. else if 블록의 마지막에는 else
 	    블록을 추가할 수 있는데, 모든 조건식이 false일 경우 else 블록을 실행하고 if문을
 	    벗어나게 된다
 	 - if (조건식1) {
 	     조건식1이 true 일 경우 실행
 	   } else if (조건식2) {
 	     조건식2가 true 일 경우 실행
 	   } else { 
 	     조건식1 및 조건식2가 false 일 경우 실행
 	   }
 	 3) 중첩 if문
 	  - if문의 블록 내부에는 또 다른 if문을 사용할 수 있다. 이것을 중첩 if문이라고
 	    부르는데, 중첩의 단계는 제한이 없다.
  	  - if문만 중첩이 되는 것이 아니고, if문, switch문, for문, while문, do-while문은 서로
 	    중첩시킬 수 있다.
 	  3-1) switch문
 	   - switch문은 변수가 어떤 값을 갖느냐에 따라 실행문이 선택된다.
 	    switch (변수) {
 	 	case 값 :
 	 	     변수가 값1일 경우 실행
 	 	     break;
 	 	case 값2 :
 	 	     변수가 값2일 경우 실행
 	 	     break;
 	 	default :
 	 	     변수가 값1, 값2 모두 아닐 경우 실행
 	    }
 	   - case 끝에 break가 없으면 다음 case가 연달아 실행되는데, 이때에는 case 값과는
 	     상관없이 실행된다.
 	   - char 타입 변수도 switch문에 사용될 수 있다.
 	   - 자바 7부터는 String 타입의 변수도 switch문에 사용될 수 있다.
반복문
 	- 반복문은 어떤 작업이 반복적으로 실행되도록 할 때 사용된다.
 	1) for문
 	 - for문은 주어진 횟수만큼 실행문을 반복 실행할 때 적합한 반복 제어문이다.
 	    for (초기화식; 조건식; 증감식) {
 	     실행문; 
 	     }
 	2) while문
 	 - while문은 조건식이 true일 경우에 계속해서 반복한다.
 	 - 조건식에는 비교 또는 논리 연산식이 주로 오는데, 조건식이 false가 되면 반복
 	   행위를 멈추고 while문을 종료한다.
 	    while (조건식) {
 	     실행문; 
 	    }
 	 - while문이 처음 실행될 때 조건식을 평가한다. 평가 결과가 true이면 실행문을 실행
 	   한다. 실행문이 모두 실행되면 다시 조건식으로 되돌아서 조건식을 다시 평가한다.
 	   만약 조건식이 true라면 앞의 과정을 다시 진행하고, false라면 while문을 종료한다.
 	3) do - while
 	  - do - while문은 조건식에 의해 반복 실행한다는 점에서 while문과 동일하다.
 	  - while문은 시작할 때부터 조건식을 검사하여 블록 내부를 실행할지 결정하지만,
 	    경우에 따라서는 블록 내부의 실행문을 우선 실행시키고 실해 결과에 따라서
 	    반복 실행을 계속할지 결정하는 경우도 발생한다. 이때 do - while문을 사용 가능
 	    do {
 	     실행문; 
 	    } while (조건식);
  	  - do - while문의 while() 뒤에는 반드시 세미콜론을 붙여야 한다.
  	  - do - while문이 처음 실행될 때 실행문을 우선 실행한다. 실행문이 모두 실행되면
 	    조건식을 평가하는데, 그 결과가 true이면 실행문 -> 조건식과 같이 반복 실행을
 	    하고, 조건식의 결과가 false이면 do - while문을 종료한다.
 	3) break문
 	  - break문은 반복문인 for문, while문, do - while문을 실행 중지할 때 사용된다.
 	    또한 switch문에서 break문을 사용하여 switch문을 종료한다.
 	  - 다음과 같이 중첩된 반복문에서 바깥쪽 반복문까지 종료시키려면 바깥쪽 반복문에
 	    이름(라벨)을 붙이고, “break 이름;”을 사용하면 된다.
 	    public static void main(String[] args) { 
 	   	Outter : for(int I = 0; I < 10; I++){
 		    for(int j=0; j<10; j++){
 			system.out.println(I,j);
 			if( j == 5){
 			   break Outter;
 			}
 		    }
 		}
 	    }
  	5) continue문
 	  - continue문은 반복문인 for문, while문, do-while문에서만 사용되는데, 블록 내부에서
 	    continue문이 실행되면 for문의 증감식 또는 while문, do-while문의 조건식으로 이동
 	  - continue문은 반복문을 종료하지 않고 계속 반복을 수행한다는 점이 break문과 다름
    
다차원 배열
 	- 2차원 배열은 수학의 행렬을 떠올리면 되는데, 가로 인덱스와 세로 인덱스를 사용한다.
 	- 자바는 2차원 배열을 중첩 배열 방식으고 구현한다. 예를 들어 2 x 3 행렬을 만들기
 	  위해 다음과 같은 코드를 사용한다.
 	   int [] [] scores = new int [2][3];
 	- 자바는 일차원 배열이 서로 연결된 구조로 배열을 구현하기 떄문에 수학 행렬 구조가
 	  아닌 계단식 구조를 가질 수 있다.
 	  int [] [] scores = new int[2] [];
 	  scores[0] = new int[2];
 	  scores[1] = new int[3];
 	- 만약 그룹화된 값 목록을 가지고 있다면 다음과 같이 중괄호 안에 다시 중괄호를
 	  사용해서 값 목록을 나열하면 된다.
 	  타입 [] [] 변수 = { {값1, 값2, …}, {값1, 값2, …} } ;
