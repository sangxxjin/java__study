객체
 	- 물리적으로 존재하거나 추상적으로 생각할 수 있는 것 중에서 자신의 속성을 가지고
 	  있고 다른 것과 식별 가능한 것을 말한다.
 	- 객체 모델링 : 현실 세계의 객체를 소프트웨어 객체로 설계하는 것.
 	- 객체들은 독립적으로 존재함. 객체들 사이의 상호작용 수단은 메소드의 호출을 통해
 	  이루어지며 매개값과 리턴값을 통해서 데이터를 주고 받음.
객체 간의 관계
 	- 집합 관계 : 하나의 부품, 하나의 완성품. (엔진/타이어/핸들 - 자동차)
 	- 사용 관계 : 객체 간의 상호작용. 다른 객체의 메소드 호출을 통해 원하는 결과 얻어냄
 	- 상속 관계 : 상위(부모)객체를 기반으로 하위(자식) 객체를 생성하는 관계 (기계 - 자동차/컴퓨터)
객체 지향 프로그램 (OOP : Object Oriented Programming)
 	- 만들고자 하는 완성품인 객체를 모델링>집합 관계에 있는 부품 객체, 사용 관계에
 	  있는 객체를 하나씩 설계한 후 조립하는 방식으로 프로그램을 개발하는 기법.
 	  특징 : 캡슐화, 상속, 다형성
 	- 캡슐화 : 객체의 필드, 메소드를 하나로 묶고 실제 구현 내용을 감추는 것.
 		  접근 제한자를 이용해 필드와 메소드의 사용 범위를 제한, 외부 객체는
 		  객체의 내부 구조를 알지 못하며 객체가 노출해서 제공하는 필드와 메소드만
 		  이용할 수 있음.
 		  why? 객체의 잘못된 사용 방지.
 	- 상속 : 상위 객체가 자기가 가지고 있는 필드와 메소드를 하위 객체에게 물려주어 하위
 		객체가 사용할 수 있도록 하는 것.
 		why? 상위 객체를 재사용해서 하위 객체를 쉽고 빨리 설계할 수 있도록 함.
 		      이미 잘 개발된 객체를 재사용하므로 코드의 중복을 줄여줌.
 	- 다형성: 하나의 타입에 여러 가지 객체를 대입함으로써 다양한 기능을 이용할 수
 		  있도록 하는 것.
 		 부모 클래스 또는 인터페이스의 타입 변환 가능, 부모 타입에 모든 자식 객체
 		 대입 가능, 인터페이스 타입에 모든 구현 객체 대입 가능.
 		 why? 객체의 부품화를 위해
인스턴스(instance)
 	- 클래스로부터 만들어진 객체를 해당 클래스의 인스턴스라고 함.
 	  하나의 클래스로부터 여러 개의 인스턴스를 만들 수 있음.
객체 생성 과정
 	- new 연산자 이용. new 생성자() 형태 : 힙 영역에 객체를 생성시킨 후, 객체의 주소를 리턴함.
 	- 생성된 객체는 메모리 힙(heap) 영역에 생성
 	- 생성된 객체를 사용하기 위해서 참조 타입인 클래스 변수에 객체의 주소 리턴.
 	- 같은 클래스로부터 생성되었지만 각각의 객체는 자신만의 고유 데이터를
 	  가지면서 메모리에서 활동함
클래스의 2가지 용도
 	1. 라이브러리용 : 다른 클래스에서 이용할 목적으로 설계
 	2. 실행용 : 하나의 클래스. 프로그램의 실행 진입점인 main() 메소드를 제공하는 역할
클래스의 구성 멤버 (필드, 생성자, 메소드)
 	1) 필드 (Field) : 객체의 고유 데이터, 부품 객체, 상태 정보를 저장하는 곳. 필드 != 변수
 	   		필드는 메소드 전체에서 사용되며 객체가 소멸되지 않는 한 객체와
 			함께 존재. 변수는 생성자와 메소드 내에서만 사용.
 	- 객체의 고유 데이터, 객체가 가져야 할 부품, 객체의 현재 상태 데이터를 저장하는 곳
 	- 필드는 생성자와 모든 메소드에서 사용 가능.
 	- 클래스 외부에서 사용할 경우 우선적으로 클래스로부터 객체를 생성한 뒤 필드를 사용
 	2) 생성자 : new 연산자로 호출되는 클래스. 객체 생성 시 초기화를 담당.
 		   필드 초기화, 메소드 호출하여 객체를 사용할 준비함.
 	- 리턴 타입이 없고 클래스 이름과 동일함.
 	- 모든 클래스는 생성자가 반드시 존재하며, 하나 이상 가질 수 있음.
 	- 기본 생성자: 클래스 내부에 생성자 선언을 생략한 경우 자동 추가되는 생성자
 		      하지만 명시적으로 선언한 생성자가 한 개라도 있으면 추가되지 않음.
 	- 클래스에 생성자가 명시적으로 선언되어 있을 경우 반드시 선언된 생성자를 호출해서
 	  객체를 생성해야 함.
 	- 생성자 역할 중 하나인 필드 초기화를 하는 2가지 방법
 	  2-1) 필드 선언 할 때 초기값을 줌 : 동일한 클래스로부터 생성되는 객체들은 모두 같은 데이터를 가짐
 	  2-2) 생성자에서 초기값을 줌 : 다양한 값들로 초기화 가능
 	- 생성자의 매개 변수 이름은 초기화시킬 필드 이름과 비슷하거나 동일한 이름 사용
 	  : 동일한 이름 사용시 생성자 내부에서 필드에 접근 할 수 없음.
 	    동일한 이름을 가진 매개 변수가 사용 우선순위가 더 높음.
 	  : this.필드명 = 매개변수명을 이용해서 초기화 가능.
 	   *this : 객체 자기 자신의 참조
 	- 중요한 필드 몇 개만 매개변수를 통해 초기화. 나머지 필드들은 필드 선언 시에
 	  초기화하거나 생성자 내부에서 임의의 값 또는 계산된 값으로 초기화 함.
 	- 생성자 오버로딩 : 매개 변수를 달리하는 생성자를 여러 개 선언 하는 것.
 	  : 타입, 개수, 순서가 달라야 함.
 	- 다른 생성자 호출(this()) : 생성자 오버로딩이 많아질 경우 생성자 간의 중복된 코드를
 				  방지하기 위해 사용하는 메소드. 자신의 다른 생성자를 호출
 				  하는 코드. 생성자의 첫줄에서만 허용. 
 				  this(매개변수1, 매개변수2) 이런 식으로 사용
 	3) 메소드 : 객체의 동작. 객체 간의 데이터 전달의 수단으로 사용. 외부로부터 매개값을
 		   받을 수도 있고, 실행 후 어떤 값을 리턴할 수도 있음.
 	- 메소드의 매개 변수의 수를 모르는 경우 매개 변수를 배열 타입으로 선언함.
 	  넘겨줄 때 배열 타입으로 넘겨 줌.
 	> int sum( int … values)로 선언 된다면 메소드 호출 시 넘겨준 값의 수에 따라
 	  자동으로 배열이 생성됨.
 	- return문이 실행되면 메소드는 즉시 종료 됨. 이후의 실행문은 결코 싱행되지 않음.
 	- 리턴값이 없는 메소드에서 return을 사용하면 메소드 실행을 강제로 종료 시킴.
 	- 메소드 오버로딩.
 	  오버로딩 : 매개 변수를 다르게 해서 같은 생성자 혹은 메소드라고 해도 다른 결과
 		    값을 내보내게 하는 것.
 		- 타입, 개수, 순서가 달라야 함.
 		- 같은 타입, 개수, 순서에 리턴 값만 다르다고해서 오버로딩이 되는 것이 아님.
인스턴스 멤버 : 객체(인스턴스)를 생성한 후 사용할 수 있는 필드와 메소드.
 		객체에 소속된 멤버이기 때문에 객체 없이는 사용할 수 없다.
정적 멤버(static) = 클래스 멤버: 클래스에 고정된 멤버, 객체를 생성하지 않고 사용할 수 있는
 		  필드와 메소드.
 		- static 키워드를 추가적으로 붙여 사용.
 		- 인스턴스, 정적 필드 판단 기준 : 객체마다 가지고 있어야 할 데이터라면
 		  인스턴스 필드, 객체마다 가지고 있을 필요성이 없는 공용적인 데이터라면
 		  정적 필드로 선언.
 		- 인스턴스, 정적 메소드 판단 기준 : 인스턴스 필드를 이용해서 실행해야
 		  한다면 인스턴스 메소드, 이용하지 않는다면 정적 메소드.
 		- 클래스.필드 / 클래스.메소드(매개값) 형식으로 바로 사용 가능. 참조 변수로도
 		  접근 가능하지만 정적 필드는 클래스 이름으로 접근하는 것이 좋음.
 		- 정적 초기화 블록 static{} : 클래스가 메모리로 로딩 될 때 자동적으로 실행 됨.
 		- 객체 생성을 하지도 않고 사용 할 수 있기 때문에 인스턴스 필드, 인스턴스
 		  메소드를 내부에서 사용할 수 없음. 객체를 먼저 생성하고 참조 변수로 접근 
싱글톤(Singleton) : 하나의 객체만 존재해야 하는 경우.
 		- 클래스 외부에서 생성자를 호출 가능하면 안됨 = 생성자 앞에 private을 붙임
Class Singleton {
 	private static Singleton singleton = new Singleton();
 	private Singleton() {}
 	static Singleton getInstance(){
 	    return singleton;
 	}
}
 		- 외부에서 사용 할 때 객체를 얻는 유일한 방법은 getInstance() 메소드를
 		  호출하는 것 = 단 하나의 객체만 리턴 함.
Final 필드 : 초기값 저장시 최종적인 값이 되어 프로그램 실행 중 수정 할 수 없는 필드.
상수(static final) : 불변의 값.
 	- 상수는 final 필드가 아님. 불변의 값은 객체마다 저장 할 필요가 없는 공용성을 띄고
 	  있지만 final 필드는 객체마다 생성자를 통해서 초기화하여 다르게 사용 할 수 있음.
 	- 객체마다 저장 할 필요가 없으므로 정적(static) 필드.
 	- 상수 이름은 대문자로 작성하는 것이 관례.
패키지 : 클래스를 체계적으로 관리하기 위해 사용
 	- 클래스를 컴파일하는 과정에서 자동으로 생성됨. package 상위패키지.하위패키지;를
 	  통하여 패키지 선언 가능. 폴더 자동 생성
 	- 관례에 따라서 이름을 지어줘야 함. (소문자, 숫자로 시작x, _/$를 제외한 특수문자x)
 	- src에 있는 모든 내용을 컴파일해서 bin 폴더에서 생성 시킴 > 생성된 bin 폴더는
 	  Window - show view - Navigator에서 확인 가능
 	- default 패키지 : 패키지에 속해있지 않은 클래스들을 저장함. = 드문 경우.
 	- 다른 패키지에 속하는 클래스를 사용하려면 import문 사용해야 함.
접근 제한자 : 데이터 보호를 위한 목적. 외부 클래스에서 접근할 수 있는 멤버와 접근 할 수
 	     없는 멤버로 구분해서 필드, 생성자, 메소드를 설계 해야 함.
	클래스 내부	동일 패키지	하위 클래스	그 외
public	o	o	o	o
protected	o	o	o	x
default	o	o	x	x
private	o	x	x	x
접근 영역 : public . protected > default > private
 	- 클래스는 public과 default 중 택 1.
 	- protected와 default 차이점 : 다른 패키지에 속한 클래스가 해당 클래스의 자식(child)
 				     클래스라면 접근 가능.
Getter, Setter 메소드 : 객체의 데이터는 객체 외부에서 직접적으로 접근하는 것을 막음.
 	- 객체의 무결성을 지키기 위함
 	- 필드 타입이 boolean일 경우 Getter는 get으로 시작하지 않고 is로 시작하는 것이 관례	
 상속
 	- 부모 클래스의 멤버를 자식 클래스에게 상속 한다.
 	- 이미 개발된 클래스를 재사용 하여 새로운 클래스를 만들어 코드의 중복을 줄여준다.
 	- 부모 클래스에서 private 접근 제한을 갖는 필드와 메소드는 상속 대상에더 제외된다.
 	- 부모 클래스와 자식 클래스가 패키지가 다르면 defualt 접근 제한을 갖는 필드와
 	  메소드는 상속 제외이다.
클래스 상속
 	- 다른 언어와는 달리 자바는 다중 상속을 허용하지 않는다. 즉 여러 개의 부모 클래스를
 	  상속할 수 없다. 그러므로 extends 다음에는 단 하나의 부모클래스만 와야 한다.
 	  ex) class ChildClass extends ParentClass {}
부모 생성자 호출
 	- 부모 객체 생성 후 자식 객체가 생성 된다.
 	- 모든 객체는 클래스의 생성자를 호출해야만 생성 된다.
 	- 생성자가 명시적으로 생성되지 않는다면 컴파일러는 기본 생성자를 생성 한다.
 	- super(매개값, ‘ ‘ ‘)은 반드시 자식 생성자 첫 줄에 위치 해야 한다.
 	public ChildClass(){
 	super(ParentClassPareameter)
 	}
메소드 재정의
 	1) 메소드 재정의(@Override)
 	 - 메소드 오버라이딩은 상속된 메소드가 자식 클래스에서 맞지 않는 경우 메소드를
 	   재정의 하는 것을 말한다.
 	 - 메소드 오버라이딩 작성 규칙
 		- 부모의 메소드와 동일한 시그니처(리턴 타입, 메소드 이름, 매개 변수 리스트)
 		  를 가져야 한다.
 		- 접근 제한을 더 강하게 오버라이딩 할 수 없다. (상속자 메소드가 public일
 		  경우 상속 받는 메소드는 접근 제한 강화를 할 수 없다. 반대는 가능하다.)
 		- 새로운 예외(Exception)를 throws 할 수 없다.
 	2) 부모 메소드 호출(super)
 	 - 자식 클래스에서 부모 클래스의 메소드를 오버라이딩하게 되면, 부모 클래스의
 	   메소드는 숨겨지고 오버라이딩된 자식 메소드만 사용한다.그러나 자식 클래스
 	   내부에서 오버라이딩된 부모 클래스의 메소드를 호출해야하는 상황이 발생한다면
 	   명시적으로 super 키워드를 붙여서 부모 메소드를 호출할 수 있다.
 	 - super는 부모 객체를 참조하기 때문에 부모 메소드에 직접 접근이 가능하다.
Final 클래스와 final 메소드
 	- final 키워드는 클래스, 필드, 메소드 선언시에 사용이 가능하다.
 	- final 키워드는 해당 선언이 최종 상태이며, 이후로 수정이 불가능함을 의미한다.
 	- final 키워드가 클래스나 필드, 메소드 선언에 사용될 경우 해석이 조금씩 달라진다.
 	1) 상속이 불가능한 final 클래스
 	 - 클래스를 선언할 때에 final 키워드를 class 앞에 붙이게 되면 이 클래스는 최종적인
 	   클래스이므로 상속할 수 없는 클래스가 된다.
 	   즉, final 클래스는 부모 클래스가 될 수 없다. 대표적인 것이 바로 String 클래스이다.
 	      ex) public class NewString extends String {} //String은 final 키워드가 붙어서 에러
 	    ex) public final class 클래스{} // final class는 곧 최종적인 클래스이므로 
      부모 클래스가 될 수 없고 따라서 자식 클래스를 만들 수 없다.
 	2) 오버라이딩 할 수 없는 final 메소드
 	 - 메소드를 선언할 때 final을 붙이게 되면 이 메소드는 최종적인 메소드가 되어 자식
 	   클래스가 오버라이딩(재정의) 할 수 없게 된다.
 	   => 오버라이딩 자체를 할 수 없고 결국 자식클래스는 부모클래스의 final 메소드를
 	       그대로 사용할 수 밖에 없다. (재정의 x)
Protected 접근 제한자
 	- protected 접근제한자는 default 접근 제한자와 달리 다른 패키지여도 자식클래스이면
 	  해당 대상(protected가 달린 필드 or 생성자 or 메소드)에 접근 가능하다. (default 접근
 	  재한자는 다른 패키지라면 절대 접근할 수 없다.)
 	- protected는 필드와 생성자, 메소드 선언에 사용될 수 있다.(클래스 자체는 불가능하다.)
타입 변환과 다형성
 	- 다형성이란 같은 타입이지만 실행 결과가 다양한 객체를 이용할 수 있는 성질을 
 	  말한다. 
 	- 코드 측면에서 보면 다형성은 하나의 타입에 여러 객체를 대입함으로써 다양한 기능을
 	  이용할 수 있도록 해준다.
 	- 다형성을 위해 자바는 부모 클래스로 타입 변환을 허용한다.
 	  즉, 부모 타입에 모든 자식 객체가 대입될 수 있다.
 	  이것을 이용하면 객체의 부품화가 가능하다.
 	- 타입변환이란 데이터 타입을 다른 데이터 타입으로 변환하는 행위를 말한다.
 	  클래스 타입도 마찬가지로 타입 변환이 가능하다.
 	  클래스 타입의 변환은 상속 관계에 있는 클래스 사이에서만 발생한다.
 	  자식 타입은 부모타입으로 자동 타입 변환이 가능하다.
 	1) 자동 타입 변환(Promotion)
 	 - 자동 타입 변환이란 프로그램 실행 도중에 자동적으로 타입 변환이 일어나는 것을
 	   말한다. 자동타입 변환은 다음과 같은 조건에서 발생한다.
 		부모 클래스 변수 = 자식 클래스 타입;
 	 - 자동 타입 변환의 개념은 자식이 부모의 특징과 기능을 상속받기 때문에, 부모와
 	   동일하게 취급될 수 있다.
 	 - 바로 위의 부모가 아니더라도 상속 계층에서 상위 타입이라면 자동 타입 변환이
 	   일어날 수 있다.
 	 - 부모 타입으로 자동 형 변환 된 이후 부모 클래스에 선언된 필드와 메소드만 접근이
 	   가능하다. 비록 변수는 자식 객체를 참조하지만 변수로 접근 가능한 멤버로 부모
 	   클래스 멤버로만 한정된다.
 	   ※ 단, 메소드가 자식 클래스에서 오버라이딩 되었다면, 자식 클래스의 메소드가 대신
 	      호출 된다.
 	2) 필드의 다형성
 	 - 다형성이란 동일한 타입을 사용하지만 다양한 결과가 나오는 성질을 말한다.
 	 - 주로 필드의 값을 다양화함으로써 실행 결과가 다르게 나오도록 구현한다.
 	 - 필드의 타입은 변함이 없지만, 실행 도중에 어떤 객체를 필드로 저장하느냐에 따라서
 	   실행 결과가 달라질 수 있다.
 	 - 객체지향 프로그램에서도 마찬가지다. 프로그램은 수많은 객체들이 서로 연결되고
 	   각자의 역할을 수행하는데, 이 객체들은 다른 객체로 교체 될 수 있어야만 한다.
 	3) 하나의 배열로 객체 관리
 	 - 보통 동일한 타입의 데이터들을 일괄적으로 관리 및 조정하기 위해서 자바는 배열을
 	   제공한다. 객체 역시 동일하게 관리가 가능하다.
 	 - 자식 클래스는 부모클래스로 자동 형변환 될 수 있기 때문에 배열 요소에 자식
 	   객체를 대입할 수 있다.
 	4) 매개 변수의 다형성
 	 - 자동 타입 변환은 필드의 값을 대입할 때에도 발생하지만, 주로 메소드를 호출할 때 
 	   많이 발생한다. => 메소드를 호출할때에는 매개 변수의 타입과 동일한 매개값을
 	   지정하는 것이 정석이지만, 매개값을 다양화하기 위해 (다형성)매개변수에 자식 타입
 	   객체를 지정할 수도 있다.
 	 - 매개 변수의 타입이 클래스일 경우, 해당 클래스의 객체 뿐만 아니라 자식 객체에까지
 	   매개값을 사용할 수 있다.
 	 - 매개값으로 어떤 자식 객체가 제공되느냐에 따라 메소드의 실행 결과는 다양해질
 	   수 있다.
 	 - 자식 객체가 부모의 메소드를 재정의했다면 메소드 내부에서 오버라이딩된 메소드를
 	   호출함으로써 메소드의 실행 결과는 다양해진다.
  	5) 강제 타입 변환(Casnting)
 	 - 강제 타입 변환은 부모 타입을 자식 타입으로 변환하는 것을 말한다.
 	 - 모든 부모타입을 자식 클래스 타입으로 강제 변환할 수 있는 것은 아니다.
 	 - 자식 타입이 부모 타입으로 자동 변환한 후, 자식 타입으로 변환할 때에 강제 타입
 	   변환을 사용할 수 있다.
 	   ex) 자식클래스 변수 = (자식클래스) 부모클래스타입;
 	 - 자식 타입이 부모 타입으로 자동 변환하면, 부모 타입에 선언된 필드와 메소드 사용
 	   가능하다는 제약 사항이 따른다.
 	 - 만약 자식 타입에 선언된 필드와 메소드를 꼭 사용해야 한다면 강제 타입 변환을
 	   해서 다시 자식 타입으로 변환한 다음 자식 타입의 필드와 메소드를 사용
 	6) 객체 타입 확인(istanceof)
 	 - 강제 타입 변환은 자식 타입이 부모 타입으로 변환되어 있는 상태에서만 가능하기
 	   때문에 다음과 같이 부모 타입의 변수가 부모 객체를 참조할 경우에은 자식 타입으로
 	   변환할 수 없습니다.
 	   Parent parent = new Parent(); Child child = (Child)parent ; // 불가능
 	 - 다형성의 단점은 부모 변수가 참조하는 객체가 부모 객체인지 자식 객체인지 알 수
 	   없다는 것이다. 부모 변수가 자동 형변환 된건지 부모 객체를 참조한 건지 모르고, 또
 	   자동 형변환 되어도 어느 자식 객체로 자동 형변환되었는지 알 수 없는 것이다.
 	 - 이 단점을 극복하기 위해 istanceof 연산자를 사용한다. 이 연산자는 부모 변수가 어떤
 	   객체를 참조하는 지 확인 시켜주는 연산자이다.
 	 - intanceof 연산자의 좌항은 객체가 오며 우항은 클래스(타입)이 온다.
 	  좌항의 객체가 우항의 인스턴스이면 true를 반환하고 아니면 false를 반환한다.
추상 클래스(Abstract Class)
 	- 객체를 실제로 생성 할 수 있는 클래스 : 실체 클래스
 	- 객체를 직접 생성 할 수 없는 클래스 : 추상 클래스 => 추상클래스 : 실체 클래스들의
 	  공통적인 특성을 추출해서 선언한 클래스
 	- 사전적으로 추상은 실체의 공통되는 특성을 추출한 것을 말한다.
 	- 클래스에서도 추상 클래스가 존재하는 데, 객체를 직접 생성할 수 있는 클래스를 실체
 	  클래스라 한다면 이 클래스들의 공통적인 특성을 추출한 것을 추상 클래스라 한다.
 	- 추상 클래스와 실체 클래스는 상속의 관계를 나타낸다. 추상 클래스와 실체 클래스는
 	  상속의 관계를 가지는데, 추상 클래스가 부모이고 실체 클래스가 자식으로 구현된다.
 	  이 때 추상 클래스의 모든 필드와 메소드는 실체 클래스들의 공통적인 것들이고, 모든
 	  실체 클래스들을 추상클래스의 모든 필드와 메소드를 물려 받는다.
 	- 추상 클래스는 실체 클래스의 공통되는 필드와 메소드를 추출해서 만들었기 떄문에
 	  객체를 직접 생성할 수는 없다. 따라서 추상클래스에는 new 연산자 사용이 불가능하고
 	  실체 클래스로 객체를 생성해야 한다.
 	- 추상 클래스로 변수는 입력하되, 실체 클래스로 객체를 대입하여도 된다.(다형성)
 	- 부모클래스, 슈퍼클래스로만 사용되며 extends 뒤에만 올 수 있는 클래스이다.
추상 클래스의 용도
 	- 실체 클래스들의 공통적인 특성(필드나 메소드)를 뽑아내어 추상 클래스로 만드는
 	  이유는 다음 2가지의 이유가 있다.
 	1) 실체 클르새들의 공통된 필드와 메소드의 이름을 통일하기 위함
 	 - 실체 클래스를 설계하는 사람이 여러 사람일 경우 실체 클래스마다 필드와 메소드가
 	   제각기 다른 이름을 가질 수 있다.
 	 - 동일한 데이터와 기능임에도 불구하고 이름이 다르다보니 객체마다 사용방법이
 	   달라진다. 
 	 - 이를 위해서 필드와 메소드 이름을 통일시켜 작업에 일관성을 높일 수 있다.
 	2) 실체 클래스를 작성할 때 시간을 절약하기 위함
 	 - 공통적인 필드와 메소드는 추상 클래스에 선언해주고 실체 클래스마다 다른점만
 	   실체 클래스에 선언하게 되면, 작성에 시간을 절약할 수 있다.
추상 클래스 선언
 	- 추상 클래스를 선언할 때에는 클래스 선언에 abstract 키워드를 붙여야 한다.
 	- abstract를 붙이게 되면 new 연산자를 이용해서 객체를 만들지 못하며, 상속을 통해
 	  자식 클래스만 만들 수 있다.
 	- 추상 클래스도 일반 클래스와 마찬가지로 필드, 생성자, 메소드 선언이 가능하다.
 	- new 연산자로 직접 생성자를 호출할 수 없지만, 자식 객체가 생성될 때 super를
 	  호출해서 추상클래스 객체를 생성하므로, 추상 클래스도 생성자가 반드시 있어야 한다.
추상 메소드와 오버라이딩
 	- 추상 클래스는 실체 클래스가 공통적으로 가져야 할 필드와 메소드를 정의해 놓은
 	  추상적인 클래스이다.
 	- 아무리 공통된 거라도, 메소드 중에는 메소드의 선언만 통일화하고, 실체 내용은 실체
 	  클래스마다 달라야 하는 경우가 있다.
 	- 이 경우 추상 메소드에서 추상 메소드를 선언하여 메소드의 선언부만 있고 메소드의 
 	  실행 내용은 실체 클래스에서 오버라이딩할 때 구체적으로 적도록하여 해결 할 수
 	  있다. (추상 메소드는 추상 클래스에서만 선언할 수 있다.)
 	public abstract class Animal {
 	public String kind ;
 	public abstract void eat() ;
 	}
 	public class Dog extends Animla {
 	public Dog() {
 	this.kind = “포유류”
 	} // 모든 동물이 어떻게 생겼는지는 잘 모르지만 일단 생물인 이상 섭취 활동을 함으로
 		자식 클래스에서는 재정의 해야만 한다.
 	@Override
 	public void eat () {
 	System.out.println( “고기를 먹는다” ) ; 
 	}
